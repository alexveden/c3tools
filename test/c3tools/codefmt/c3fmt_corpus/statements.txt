================================================================================
generic_statements
================================================================================

fn void main() 
{ 
int a = b;
b|= 10+a;
 io :: printf(   "soo"   , a   );
v  .  
    @call(a, b);
return;
}

--------------------------------------------------------------------------------
fn void main()
{
    int a = b;
    b |= 10 + a;
    io::printf("soo", a);
    v.@call(a, b);
    return;
}
================================================================================
multiple_decl
================================================================================

fn void main() 
{ 
int a,b,c;
}

--------------------------------------------------------------------------------
fn void main()
{
    int a, b, c;
}
================================================================================
call_statement_single_line
================================================================================

fn void main() 
{ 
    io::printf("soo", a, sooo::  foo::bar  (    "adskjalsda", looooong, var1));
    io::printf(
        "soo", a, 
        sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    );
return;
}

--------------------------------------------------------------------------------
fn void main()
{
    io::printf("soo", a, sooo::foo::bar("adskjalsda", looooong, var1));
    io::printf(
        "soo", a, sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    );
    return;
}
================================================================================
double_long_call
================================================================================

fn void main() 
{ 
    return io::printf("soo", a, sooo::  foo::bar  (    "adskjalsda", looooong, var1)) + 
    io::printf(
        "soo", a, 
        sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    );
}

--------------------------------------------------------------------------------
fn void main()
{
    return io::printf(
        "soo",
        a,
        sooo::foo::bar("adskjalsda", looooong, var1)
    ) + io::printf(
        "soo",
        a,
        sooo::foo::bar("adskjalsda", looooong, var1),
        another_var1
    );
}
================================================================================
arith_and_long_call
================================================================================

fn void main() 
{ 
    return 2 + foo_log_long + 
    io::printf(
        "soo", a, 
        sooo::foo::bar("adskja", looong, var1), another_var1
    ) + bar;
}

--------------------------------------------------------------------------------
fn void main()
{
    return 2 + foo_log_long + io::printf(
        "soo", a, sooo::foo::bar("adskja", looong, var1), another_var1
    ) + bar;
}
================================================================================
logical_with_calls_in_parens
================================================================================

fn void main() 
{ 
    return (foo_log_long || bar && 
    io::printf(
        "soo", a, 
        sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    ) || bar);
}

--------------------------------------------------------------------------------
fn void main()
{
    return (
        foo_log_long ||
        bar &&
        io::printf("soo", a, sooo::foo::bar("adskjalsda", looooong, var1), another_var1) ||
        bar
    );
}
================================================================================
logical_with_calls_no_parens
================================================================================

fn void main() 
{ 
    return foo_log_long || bar && 
    io::printf(
        "soo", a, 
        sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    ) || bar;
}

--------------------------------------------------------------------------------
fn void main()
{
    return foo_log_long || bar && io::printf(
        "soo",
        a,
        sooo::foo::bar("adskjalsda", looooong, var1),
        another_var1
    ) || bar;
}
================================================================================
chained_call
================================================================================

fn void main() 
{ 
    return 
    io::printf(
        "soo", a, 
        sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    ).foo(a).bar(b).baz(c);
}

--------------------------------------------------------------------------------
fn void main()
{
    return io::printf(
        "soo",
        a,
        sooo::foo::bar("adskjalsda", looooong, var1),
        another_var1
    ).foo(
        a
    ).bar(
        b
    ).baz(
        c
    );
}
================================================================================
assignment_with_call
================================================================================

fn void main() 
{ 
    foo[call(some,1,4, very_long_parametesr, anothe_one)] =
    io::printf(
        "soo", a, 
        sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    );
}

--------------------------------------------------------------------------------
fn void main()
{
    foo[call(some, 1, 4, very_long_parametesr, anothe_one)] = io::printf(
        "soo", a, sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    );
}
================================================================================
assignment_left_too_long
================================================================================

fn void main() 
{ 
    foo[call(some,1,4, very_long_parametesr, anothe_one, "some stuff is going on it's too wide")] =
    io::printf(
        "soo", a, 
        sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    );
}

--------------------------------------------------------------------------------
fn void main()
{
    foo[call(some, 1, 4, very_long_parametesr, anothe_one, "some stuff is going on it's too wide")] = io::printf(
        "soo", a, sooo::foo::bar("adskjalsda", looooong, var1), another_var1
    );
}
================================================================================
designated_initializers_struct
================================================================================

fn void main() 
{ 
    MyStruct foo = {.hello=1,.world =2};
}

--------------------------------------------------------------------------------
fn void main()
{
    MyStruct foo = { .hello = 1, .world = 2 };
}
================================================================================
designated_initializers_struct_wrap
================================================================================

fn void main() 
{ 
    MyStruct foo = {.hello=1,.world =2, .anothe_call = io::prinf("hi there it's c3fmt")   };
}

--------------------------------------------------------------------------------
fn void main()
{
    MyStruct foo = {
        .hello = 1, .world = 2, .anothe_call = io::prinf("hi there it's c3fmt")
    };
}
================================================================================
designated_initializers_struct_wrap_multiline
================================================================================

fn void main() 
{ 
    MyStruct foo = {.question = "how long it could be", .hello=1,.world =2, .anothe_call = io::prinf("hi there it's c3fmt")  , .this_is_a_lloong_field = (x & 12) };
}

--------------------------------------------------------------------------------
fn void main()
{
    MyStruct foo = {
        .question = "how long it could be",
        .hello = 1,
        .world = 2,
        .anothe_call = io::prinf("hi there it's c3fmt"),
        .this_is_a_lloong_field = (x & 12)
    };
}
================================================================================
designated_initializers_with_sub_structs
================================================================================

fn void main() 
{ 
    MyStruct foo = {.question = "how long it could be",
        .sub = {.hello=1,.world =2, .sub_sub = {.foo = bar, .zoo= bas}, 
            .anothe_call = io::prinf(Foo{.nowrap=true}, "hi there it's c3fmt")  ,

            .a_call_unwrappe = io::prinf_wrapped_if_struct(long_argument_name, "another",  "hi there it's c3fmt") ,


            .this_is_a_lloong_field = (x & 12) },        
            };
}

--------------------------------------------------------------------------------
fn void main()
{
    MyStruct foo = {
        .question = "how long it could be",
        .sub = {
            .hello = 1,
            .world = 2,
            .sub_sub = {
                .foo = bar,
                .zoo = bas
            },
            .anothe_call = io::prinf(Foo {
                .nowrap = true
            },"hi there it's c3fmt"),
            .a_call_unwrappe = io::prinf_wrapped_if_struct(long_argument_name,"another","hi there it's c3fmt"),
            .this_is_a_lloong_field = (x & 12)
        },
    };
}
================================================================================
if_statement_simple
================================================================================

fn void main() 
{ 
if(   
    doo)
    {
    return
    0;}
}

--------------------------------------------------------------------------------
fn void main()
{
    if (doo) {
        return 0;
    }
}
================================================================================
if_statement_simple_inside_if
================================================================================

fn void main() 
{ 
if(   
    doo)
    {
        if(foo){ return 1;}
    return
    0;}
return 200;
}

--------------------------------------------------------------------------------
fn void main()
{
    if (doo) {
        if (foo) {
            return 1;
        }
        return 0;
    }
    return 200;
}
================================================================================
if_statement_simple_sub_with_looong_condition
================================================================================

fn void main() 
{ 
if(   
    doo)
    {
        if(foo_bar(soo, okr) || fffff || zzz.another.foo(1, 2, 3) && a_little_bit ){ return 1;}
    return
    0;}
return 200;
}

--------------------------------------------------------------------------------
fn void main()
{
    if (doo) {
        if (
            foo_bar(soo, okr) ||
            fffff ||
            zzz.another.foo(1, 2, 3) &&
            a_little_bit
        ) {
            return 1;
        }
        return 0;
    }
    return 200;
}
================================================================================
if_statement_with_label
================================================================================

fn void main() 
{ 
if LABEL : (   
    doo)
    {
        if ANOTHER: (foo_bar(soo, okr) || fffff || zzz.another.foo(1, 2, 3) && a_little_bit ){ return 1;}
    return
    0;}
return 200;
}

--------------------------------------------------------------------------------
fn void main()
{
    if LABEL: (doo) {
        if ANOTHER: (
            foo_bar(soo, okr) ||
            fffff ||
            zzz.another.foo(1, 2, 3) &&
            a_little_bit
        ) {
            return 1;
        }
        return 0;
    }
    return 200;
}
================================================================================
if_single_line
================================================================================

fn void main() 
{ 
if LABEL : (   
    doo)
        zzz.another.foo(1, 2, 3);
return 200;
}

--------------------------------------------------------------------------------
fn void main()
{
    if LABEL: (doo) zzz.another.foo(1, 2, 3);
    return 200;
}
================================================================================
if_single_line_never_wraps
================================================================================

fn void main() 
{ 
if LABEL : (   
    doo)
        zzz.another.foo(whit_is_too_long, and_maybe(another, call, ther), 3);
return 200;
}

--------------------------------------------------------------------------------
fn void main()
{
    if LABEL: (doo) zzz.another.foo(whit_is_too_long, and_maybe(another, call, ther), 3);
    return 200;
}
================================================================================
if_else_simple
================================================================================

fn void main() 
{ 
if(   
    doo)
    {
    return
    0;} else   
    {
    return 3;
    }
}

--------------------------------------------------------------------------------
fn void main()
{
    if (doo) {
        return 0;
    } else {
        return 3;
    }
}
================================================================================
if_elseif_simple
================================================================================

fn void main() 
{ 
if(   
    doo)
    {
    return
    0;} else  if  (
    bar
    )
    {
    return 3;
    }
}

--------------------------------------------------------------------------------
fn void main()
{
    if (doo) {
        return 0;
    } else if (bar) {
        return 3;
    }
}
================================================================================
for_loop
================================================================================

fn void main() 
{ 
for TOP  : (   
    int i=0;i< foo(call, some);i++)
    {
        break TOP  ;
        break;
        continue;
        continue TOP;
        continue TOP  :;
    return
    0;}} 

--------------------------------------------------------------------------------
fn void main()
{
    for TOP: (int i = 0; i < foo(call, some); i++) {
        break TOP;
        break;
        continue;
        continue TOP;
        continue TOP:;
        return 0;
    }
}
================================================================================
for_loop_long_wrap_axis_semicol
================================================================================

fn void main() 
{ 
for(   
    int i=foo.launch(some, stuff, kwarg: in_loong);i< foo(call, some) && another_long_condition;i++)
    {
    return
    0;}} 

--------------------------------------------------------------------------------
fn void main()
{
    for (
        int i = foo.launch(some, stuff, kwarg: in_loong);
        i < foo(call, some) && another_long_condition;
        i++
    ) {
        return 0;
    }
}
================================================================================
for_loop_infinite
================================================================================

fn void main() 
{ 
for(   
    ; ; ;)
    {
    return
    0;}} 

--------------------------------------------------------------------------------
fn void main()
{
    for (;;;) {
        return 0;
    }
}
================================================================================
while_loop
================================================================================

fn void main() 
{ 
while(   
    foo.launch(some, stuff, kwarg: in_loong) || i< foo(call, some) && another_long_condition)
    {
    return
    0;}} 

--------------------------------------------------------------------------------
fn void main()
{
    while (
        foo.launch(some, stuff, kwarg: in_loong) ||
        i < foo(call, some) &&
        another_long_condition
    ) {
        return 0;
    }
}
================================================================================
foreach_loop_single
================================================================================

fn void main() 
{ 
foreach(i   ,    z :   
    foo)
    {
    return
    0;}} 

--------------------------------------------------------------------------------
fn void main()
{
    foreach (i, z : foo) {
        return 0;
    }
}
================================================================================
foreach_r_loop_single
================================================================================

fn void main() 
{ 
foreach_r(i:
    foo)
    {
    return
    0;}} 

--------------------------------------------------------------------------------
fn void main()
{
    foreach_r (i : foo) {
        return 0;
    }
}
================================================================================
foreach_loop
================================================================================

fn void main() 
{ 
foreach(i   ,    z :   
    foo.launch(some, stuff, kwarg: in_loong) || i< foo(call, some) && another_long_condition)
    {
    return
    0;}} 

--------------------------------------------------------------------------------
fn void main()
{
    foreach (
        i, z :
        foo.launch(some, stuff, kwarg: in_loong) || i < foo(call, some) && another_long_condition
    ) {
        return 0;
    }
}
================================================================================
foreach_r_loop
================================================================================

fn void main() 
{ 
  foreach_r   (i   ,    z :   
    foo.launch(some, stuff, kwarg: in_loong) || i< foo(call, some) && another_long_condition)
    {
    return
    0;}} 

--------------------------------------------------------------------------------
fn void main()
{
    foreach_r (
        i, z :
        foo.launch(some, stuff, kwarg: in_loong) || i < foo(call, some) && another_long_condition
    ) {
        return 0;
    }
}
================================================================================
defer_inline
================================================================================

fn void main() 
{ 
    defer foo.launch(some, stuff, kwarg: in_loong);
    return
    0;} 

--------------------------------------------------------------------------------
fn void main()
{
    defer foo.launch(some, stuff, kwarg: in_loong);
    return 0;
}
================================================================================
defer_braces
================================================================================

fn void main() 
{ 
    defer { foo.launch(some, stuff, kwarg: in_loong);  if(too) {return 0;}}
    return
    0;} 

--------------------------------------------------------------------------------
fn void main()
{
    defer {
        foo.launch(some, stuff, kwarg: in_loong);
        if (too) {
            return 0;
        }
    }
    return 0;
}
================================================================================
switch_empty
================================================================================

fn void main() 
{ 
    switch {}
    return
    0;} 

--------------------------------------------------------------------------------
fn void main()
{
    switch {
    }
    return 0;
}
================================================================================
switch_empty_condition_wrap
================================================================================

fn void main() 
{ 
    switch LABEL: (    foo.launch(
        some, stuff, 
        kwarg: in_loong, this_is_another_looong_looong_field) ) {  }  
    return
    0;} 

--------------------------------------------------------------------------------
fn void main()
{
    switch LABEL: (
        foo.launch(some, stuff, kwarg: in_loong, this_is_another_looong_looong_field)
    ) {
    }
    return 0;
}
================================================================================
designated_initializers_struct_magic_comma
================================================================================

fn void main() 
{ 
    MyStruct foo = {.hello=1,.world =2,};
}

--------------------------------------------------------------------------------
fn void main()
{
    MyStruct foo = {
        .hello = 1,
        .world = 2,
    };
}
================================================================================
switch_with_cases_and_default
================================================================================

fn void main() 
{ 
    switch LABEL: (    foo.launch(
        some, stuff, 
        kwarg: in_loong) ) {  
            case FOO:
            bar();
            case BAR:
            case BAZ:
            case "another":
            case 922:
                    if(foo) nextcase STATE: state.transition(SCOPE);
            case 1..0xffff:
            foo();
            default:  nextcase LABEL : FOO;
        }  
    return
    0;} 

--------------------------------------------------------------------------------
fn void main()
{
    switch LABEL: (foo.launch(some, stuff, kwarg: in_loong)) {
        case FOO:
            bar();
        case BAR:
        case BAZ:
        case "another":
        case 922:
            if (foo) nextcase STATE: state.transition(SCOPE);
        case 1..0xffff:
            foo();
        default:
            nextcase LABEL: FOO;
    }
    return 0;
}
================================================================================
switch_with_cases_in_braces
================================================================================

fn void main() 
{ 
    switch LABEL: (    foo.launch(
        some, stuff, 
        kwarg: in_loong) ) {  
            case FOO: {
            bar() ; }
            case BAR:
            case BAZ:
            case "another"   :

            case 922:
            case 1..0xffff:
            foo();
            default   : {  nextcase LABEL : FOO;  }
                
        }  
    return
    0;} 

--------------------------------------------------------------------------------
fn void main()
{
    switch LABEL: (foo.launch(some, stuff, kwarg: in_loong)) {
        case FOO: {
            bar();
        }
        case BAR:
        case BAZ:
        case "another":

        case 922:
        case 1..0xffff:
            foo();
        default: {
            nextcase LABEL: FOO;
        }

    }
    return 0;
}
================================================================================
scope_in_scope
================================================================================

fn void main() 
{ 
{  foo = 0;}

    return
    0;} 

--------------------------------------------------------------------------------
fn void main()
{
    {
        foo = 0;
    }

    return 0;
}
================================================================================
defer_catch
================================================================================

fn void main() 
{ 
defer (   catch 
err)
io::printfn("fault found: %s", err);

    return
    0;} 

--------------------------------------------------------------------------------
fn void main()
{
    defer (catch err) io::printfn("fault found: %s", err);

    return 0;
}
================================================================================
defer_catch_full_example
================================================================================

fn  char[   ]   ! test   ()
{
    defer (catch 
    err)
    {
        io::printfn("Excuse found: %s", 
        err);
        (void)   
        free(data);
            (t.type=
            EMPTY_LINE);
    }
    // Returns Excuse, memory gets freed
    return IoError.FILE_NOT_FOUND?;
}

--------------------------------------------------------------------------------
fn char[]! test()
{
    defer (catch err) {
        io::printfn("Excuse found: %s", err);
        (void)free(data);
        (t.type = EMPTY_LINE);
    }
    // Returns Excuse, memory gets freed
    return IoError.FILE_NOT_FOUND?;
}
================================================================================
defer_catch_no_paren
================================================================================

fn  char[   ]   ! test   ()
{
    defer catch
        io::printfn("Excuse found: %s", 
        err);
    return IoError.FILE_NOT_FOUND?;
}

--------------------------------------------------------------------------------
fn char[]! test()
{
    defer catch io::printfn("Excuse found: %s", err);
    return IoError.FILE_NOT_FOUND?;
}
================================================================================
defer_catch_braces
================================================================================

fn  char[   ]   ! test   ()
{
    defer catch 
        {io::printfn("Excuse found: %s", 
        err);}
    return IoError.FILE_NOT_FOUND?;
}

--------------------------------------------------------------------------------
fn char[]! test()
{
    defer catch {
        io::printfn("Excuse found: %s", err);
    }
    return IoError.FILE_NOT_FOUND?;
}
================================================================================
if_catch_return_excuse
================================================================================

fn  char[   ]   ! test   ()
{
if (catch excuse = foo(call, dab))
                {
            // Return the excuse with ? operator
    return excuse?;
    }
}

--------------------------------------------------------------------------------
fn char[]! test()
{
    if (catch excuse = foo(call, dab)) {
        // Return the excuse with ? operator
        return excuse?;
    }
}
================================================================================
if_catch_switch
================================================================================

fn void! test()
{
if (catch excuse = optional_value)
            {
    case NoHomework.DOG_ATE_MY_HOMEWORK:
                io::printn("Dog ate your file");
case IoError.FILE_NOT_FOUND:
            io::printn("File not found");
            default: {
            io::printfn("Unexpected Excuse: %s", excuse);
            return excuse?;}
    }
}

--------------------------------------------------------------------------------
fn void! test()
{
    if (catch excuse = optional_value) {
        case NoHomework.DOG_ATE_MY_HOMEWORK:
            io::printn("Dog ate your file");
        case IoError.FILE_NOT_FOUND:
            io::printn("File not found");
        default: {
            io::printfn("Unexpected Excuse: %s", excuse);
            return excuse?;
        }
    }
}
================================================================================
body_macro
================================================================================

fn  char[   ]   ! test   ()
{
        c.@foo( a, b ; xyz , abcj ) 
        { xyz[1] =    4;};
    return 0;
}

--------------------------------------------------------------------------------
fn char[]! test()
{
    c.@foo(a, b; xyz, abcj) {
        xyz[1] = 4;
    };
    return 0;
}
================================================================================
expr_block
================================================================================

fn  char[   ]   ! test   ()
{
    int foo = {| int a = 0; return a+1; |}  ! ;  
    return 0;
}

--------------------------------------------------------------------------------
fn char[]! test()
{
    int foo = {|
        int a = 0;
        return a + 1;
    |}!;
    return 0;
}
================================================================================
expr_block_bangbang
================================================================================

fn  char[   ]   ! test   ()
{
    int foo = {| int a = 0; return a+1; |}  !! ;  
    return 0;
}

--------------------------------------------------------------------------------
fn char[]! test()
{
    int foo = {|
        int a = 0;
        return a + 1;
    |}!!;
    return 0;
}
================================================================================
switch_jump_atts
================================================================================

fn void main() 
{ 
    switch LABEL: (    foo.launch(
        some, stuff, 
        kwarg: in_loong) ) @jump   {  }  
    return
    0;} 

--------------------------------------------------------------------------------
fn void main()
{
    switch LABEL: (foo.launch(some, stuff, kwarg: in_loong)) @jump {
    }
    return 0;
}
================================================================================
switch_conditional
================================================================================

fn void main()
{
switch
{
    case 
    foo() > 0:   bar();
    case test() == 
    1:   baz();
    case 
    (foo_too_long(a, tb, sz) > 0 && another_too_loong(maybe) && just_one_more_condition > 0):   bar();
}
}
--------------------------------------------------------------------------------
fn void main()
{
    switch {
        case foo() > 0:
            bar();
        case test() == 1:
            baz();
        case (
            foo_too_long(a, tb, sz) > 0 &&
            another_too_loong(maybe) &&
            just_one_more_condition > 0
        ):
            bar();
    }
}
================================================================================
asm_block
================================================================================

fn void main()
{
int aa = 3;
int g;
int* gp = &g;
int* xa = &a;
usz asf = 1;
asm("nop");
asm 
    {
            movl x, 4;                  // Move 4 into the variable x
            movl [gp], {x};             // Move the value of x into the address in gp
            movl x, 1;                  // Move 1 into x
            movl [xa + asf * 4 + 4], x; // Move x into the address at xa[asf + 1]
            movl $eax, (23 + x);        // Move 23 + x into EAX
            movl x, $eax;               // Move EAX into x
            movq [&z], 33;              // Move 33 into the memory address of z
    }
if( foo) { return 1;}
}
--------------------------------------------------------------------------------
fn void main()
{
    int aa = 3;
    int g;
    int* gp = &g;
    int* xa = &a;
    usz asf = 1;
    asm("nop");
    asm
    {
            movl x, 4;                  // Move 4 into the variable x
            movl [gp], {x};             // Move the value of x into the address in gp
            movl x, 1;                  // Move 1 into x
            movl [xa + asf * 4 + 4], x; // Move x into the address at xa[asf + 1]
            movl $eax, (23 + x);        // Move 23 + x into EAX
            movl x, $eax;               // Move EAX into x
            movq [&z], 33;              // Move 33 into the memory address of z
    }
    if (foo) {
        return 1;
    }
}
================================================================================
designated_initializers_array
================================================================================

fn void main()
{
int[3] a = { 1, 2, 3 };
int[*] b = { 4, 5, 6 }; // Type inferred to be int[3]
int[] b2 = a[0 : 5]; // { 1, 20, 50, 100, 200 } start-index 0, slice-length 5
    int[] c2 = a[2 :];
    int[] c2 = a[2 .. ];
    int[] c2 = a[.. 2];
    int[] c2 = a[..  ];
    int[] c2 = a[ : ];
    int[] c2 = a[ : ^77];
    int[<?>] c2 = {1, 2, 3};
    int[] c2 = a[ ^ 77];
int[][4] unwrapped_array = { {1},{2, 3},{7, 8, 9, 10}};
    int[][4] array_magic_comma = {
    { 1 },
    { 2, 3 },
};
int[][4] wrapped_1line_array = { {1},{2, 3},{4, 5, 6},{7, 8, 9, 10},{7, 8, 9, 10}};
}

--------------------------------------------------------------------------------
fn void main()
{
    int[3] a = { 1, 2, 3 };
    int[*] b = { 4, 5, 6 };  // Type inferred to be int[3]
    int[] b2 = a[0:5];  // { 1, 20, 50, 100, 200 } start-index 0, slice-length 5
    int[] c2 = a[2:];
    int[] c2 = a[2..];
    int[] c2 = a[..2];
    int[] c2 = a[..];
    int[] c2 = a[:];
    int[] c2 = a[:^77];
    int[<?>] c2 = { 1, 2, 3 };
    int[] c2 = a[^77];
    int[][4] unwrapped_array = { {1}, {2, 3}, {7, 8, 9, 10} };
    int[][4] array_magic_comma = {
        {1},
        {2, 3},
    };
    int[][4] wrapped_1line_array = {
        {1}, {2, 3}, {4, 5, 6}, {7, 8, 9, 10}, {7, 8, 9, 10}
    };
}
================================================================================
vectors_arrays_generic
================================================================================

fn void main()
{
    int[<2>] a = { 23, 11 };
    int[<2>] b = { 2, 1 };
    int[<3>] a = { 11, 22, 33 };
    List(<int >) l = List.new(doo, 1);
    int[<4>] b = a.xxzx;                         // b = { 11, 11, 33, 11 }
    int c = b.w;                                 // c = 11;
    char[<4>] color = { 0x11, 0x22, 0x33, 0xFF };
    char red = color.r;                          // red = 0x11
    test_float(1.0, &f);
    foo_test::test(<int, double>) ( 1.0, &g );
    int[<2>] c = { a[0] * b[0], a[1] * b[1] };
}

--------------------------------------------------------------------------------
fn void main()
{
    int[<2>] a = { 23, 11 };
    int[<2>] b = { 2, 1 };
    int[<3>] a = { 11, 22, 33 };
    List(<int>) l = List.new(doo, 1);
    int[<4>] b = a.xxzx;  // b = { 11, 11, 33, 11 }
    int c = b.w;  // c = 11;
    char[<4>] color = { 0x11, 0x22, 0x33, 0xFF };
    char red = color.r;  // red = 0x11
    test_float(1.0, &f);
    foo_test::test(<int, double>)(1.0, &g);
    int[<2>] c = { a[0] * b[0], a[1] * b[1] };
}
================================================================================
array_initializers
================================================================================

fn void main()
{
int[256] x = { [0..128] = 1, [0] = {.a = b, .c = 1} };
}

--------------------------------------------------------------------------------
fn void main()
{
    int[256] x = { [0..128] = 1, [0] = {.a = b, .c = 1} };
}
================================================================================
array_initializers_wide
================================================================================

fn void main()
{
int[256] x = { [0..128] = 1, [0] = {.a = b, .c = 1}, [77] = {.soo = 0, .a = 1} };
}

--------------------------------------------------------------------------------
fn void main()
{
    int[256] x = {
        [0..128] = 1, [0] = {.a = b, .c = 1}, [77] = {.soo = 0, .a = 1}
    };
}
================================================================================
array_initializers_multiline
================================================================================

fn void main()
{
int[256] x = { [0..128] = 1, [0] = {.a = b, .c = 1},
[77] = {.soo = looong, .another = 1}, 
[888] = one_moar(call, should, be, one, line ) };
}

--------------------------------------------------------------------------------
fn void main()
{
    int[256] x = {
        [0..128] = 1,
        [0] = {.a = b, .c = 1},
        [77] = {.soo = looong, .another = 1},
        [888] = one_moar(call, should, be, one, line)
    };
}
================================================================================
pointers
================================================================================

fn void main()
{
VoidFunc a = &test;
int b = (int)null;
int c = (int)a; // Invalid, not constant
int d = (int)((int*)1); // Invalid, not constant
byte a = 1;
int* b = (int*)a; // Invalid, pointer type is > 8 bits.
int* c = (int*)1; // Valid, but runtime value.
int* d = (int*)0; // Valid and constant value.
}

--------------------------------------------------------------------------------
fn void main()
{
    VoidFunc a = &test;
    int b = (int)null;
    int c = (int)a;  // Invalid, not constant
    int d = (int)((int*)1);  // Invalid, not constant
    byte a = 1;
    int* b = (int*)a;  // Invalid, pointer type is > 8 bits.
    int* c = (int*)1;  // Valid, but runtime value.
    int* d = (int*)0;  // Valid and constant value.
}
================================================================================
module_import
================================================================================
module test::std::core::test @test @if(FOO || BAR);
import std::core::test    @public;
import std::core:: builtin;
import 
std::io;
module math_tests::complex   (< ElementType >) @test;
--------------------------------------------------------------------------------
module test::std::core::test @test @if(FOO || BAR);
import std::core::test @public;
import std::core::builtin;
import std::io;
module math_tests::complex(<ElementType>) @test;
================================================================================
const
================================================================================
const Time FAR_FUTURE = long.max;
const ulong WIN_TO_UNIX_EPOCH_US @local = 116444736000000000u64 / WINDOWS_TICK_US;
const CONTEXT_AMD64_ALL = CONTEXT_AMD64_CONTROL | CONTEXT_AMD64_INTEGER | CONTEXT_AMD64_SEGMENTS | CONTEXT_AMD64_FLOATING_POINT | CONTEXT_AMD64_DEBUG_REGISTERS;
const char[?] HEXALPHABET @private = "0123456789abcdef";
const Base64Alphabet URL = {
.encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
.reverse = 2
};
const bool KEY_BY_VALUE @private = NO_KEY_FN ||| $assignable(Type{}[0], $typefrom(KeyFn.paramsof[0].type));
const bool KEY_BY_VALUE @private = $assignable(Type{}[0], $typefrom(KeyFn.paramsof[0].type)) ||| $assignable(Type{}[0], $typefrom(KeyFn.paramsof[0].type));
const Foo F4 = (F1 | ~F2) ^ F3;
const Foo F5 = Foo { true, false } | Foo { false, true };
const char[?] TEST_QOI_DATA = b64"cW9pZgAAAVQAAACpBABV/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39";

--------------------------------------------------------------------------------
const Time FAR_FUTURE = long.max;
const ulong WIN_TO_UNIX_EPOCH_US @local = 116444736000000000u64 / WINDOWS_TICK_US;
const CONTEXT_AMD64_ALL = CONTEXT_AMD64_CONTROL | CONTEXT_AMD64_INTEGER | CONTEXT_AMD64_SEGMENTS | CONTEXT_AMD64_FLOATING_POINT | CONTEXT_AMD64_DEBUG_REGISTERS;
const char[?] HEXALPHABET @private = "0123456789abcdef";
const Base64Alphabet URL = {
    .encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    .reverse = 2
};
const bool KEY_BY_VALUE @private = NO_KEY_FN ||| $assignable(
    Type {}[0], $typefrom(KeyFn.paramsof[0].type)
);
const bool KEY_BY_VALUE @private = $assignable(
    Type {}[0],
    $typefrom(KeyFn.paramsof[0].type)
) ||| $assignable(
    Type {}[0],
    $typefrom(KeyFn.paramsof[0].type)
);
const Foo F4 = (F1 | ~F2) ^ F3;
const Foo F5 = Foo { true, false } | Foo { false, true };
const char[?] TEST_QOI_DATA = b64"cW9pZgAAAVQAAACpBABV/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39";
================================================================================
extern_func
================================================================================
extern fn Test func_returning_struct();
extern fn int printf(char *str, ...);
extern fn void* __asan_region_is_poisoned(void* beg, usz size);
extern fn void __sanitizer_weak_hook_strcmp(void* called_pc, ZString s1, ZString s2, CInt result);
extern fn Char16** _win_command_line_to_argv_w(ushort* cmd_line, int* argc_ptr) @extern("CommandLineToArgvW");
extern fn int! maybe();
extern fn Win32_BOOL win32_QueryPerformanceFrequency(Win32_LARGE_INTEGER* lpFrequency) @extern("QueryPerformanceFrequency");
extern Char16* _win_command_line_to_argv_w;
extern const int FOO @extern("foo1");
extern void *__stdoutp;
extern const char *manifest_default_keys[][2];

--------------------------------------------------------------------------------
extern fn Test func_returning_struct();
extern fn int printf(char* str, ...);
extern fn void* __asan_region_is_poisoned(void* beg, usz size);
extern fn void __sanitizer_weak_hook_strcmp(
    void* called_pc, ZString s1, ZString s2, CInt result
);
extern fn Char16** _win_command_line_to_argv_w(ushort* cmd_line, int* argc_ptr) @extern("CommandLineToArgvW");
extern fn int! maybe();
extern fn Win32_BOOL win32_QueryPerformanceFrequency(
    Win32_LARGE_INTEGER* lpFrequency
) @extern("QueryPerformanceFrequency");
extern Char16* _win_command_line_to_argv_w;
extern const int FOO @extern("foo1");
extern void* __stdoutp;
extern const char* manifest_default_keys[][2];
================================================================================
do_while
================================================================================
fn void main()
{
do
{   io::printn("FOO");
} while (0);
do
{
    io::printn("FOO");
};
}
--------------------------------------------------------------------------------
fn void main()
{
    do {
        io::printn("FOO");
    } while(0);
    do {
        io::printn("FOO");
    };
}
================================================================================
designated_initializers_array_of_structs
================================================================================

fn void main()
{
int[][4] wrapped_array = { run_stuff_of_someth(),{.foo = 2, .bar = 3},{.sub = 1}, {1,2,3}};
}

--------------------------------------------------------------------------------
fn void main()
{
    int[][4] wrapped_array = {
        run_stuff_of_someth(), {.foo = 2, .bar = 3}, {.sub = 1}, {1, 2, 3}
    };
}
================================================================================
designated_initializers_array_of_structs_magic_comma
================================================================================

fn void main()
{
int[][4] wrapped_array = { run_stuff_of_someth(),{.foo = 2, .bar = 3},{.sub = 1}, {1,2,3},};
}

--------------------------------------------------------------------------------
fn void main()
{
    int[][4] wrapped_array = {
        run_stuff_of_someth(),
        {.foo = 2, .bar = 3},
        {.sub = 1},
        {1, 2, 3},
    };
}
================================================================================
designated_initializers_with_arrays
================================================================================

fn void main()
{
    argparse::ArgParse agp = {
        .description = "c3 code formatting tool",
        .usage = "[options] file1 .. fileN",
        .options = { 
            argparse::help_opt(),
            {1, 3, 4, 5, 6},
            argparse::group_opt("Basic options"),
            { .short_name = 'f', .long_name = "force",  .value = &force_mode, .help = "force formatting non .c3 files"},
            { .short_name = 'n', .long_name = "dry",  .value = &dry_mode, .help = "dry mode (only print)"},
            argparse::group_opt("Code format options"),
            { .short_name = 'w', .long_name = "line-width",  .value = &max_line_width, .help = "max line width"},
        }, 
    };
}

--------------------------------------------------------------------------------
fn void main()
{
    argparse::ArgParse agp = {
        .description = "c3 code formatting tool",
        .usage = "[options] file1 .. fileN",
        .options = {
            argparse::help_opt(),
            {
                1,
                3,
                4,
                5,
                6
            },
            argparse::group_opt("Basic options"),
            {
                .short_name = 'f',
                .long_name = "force",
                .value = &force_mode,
                .help = "force formatting non .c3 files"
            },
            {
                .short_name = 'n',
                .long_name = "dry",
                .value = &dry_mode,
                .help = "dry mode (only print)"
            },
            argparse::group_opt("Code format options"),
            {
                .short_name = 'w',
                .long_name = "line-width",
                .value = &max_line_width,
                .help = "max line width"
            },
        },
    };
}
================================================================================
struct_designated_init_in_different_ctx
================================================================================

fn void main() 
{ 
    MyStruct foo = {};
    MyStruct foo = {1, 2,3};
    MyStruct foo = {.bax = 2};
    MyStruct foo_magic = {.bax = 2,};
    call(MyStruct{}, Bar   {.soo = 1, });
    call(MyStruct{1, 2, 3});
    MyStruct foo = (MyStruct)call(MyStruct{1, 2, 3});
    MyStruct foo = (MyStruct)call(MyStruct{1, 2, 3, });
}

--------------------------------------------------------------------------------
fn void main()
{
    MyStruct foo = {};
    MyStruct foo = { 1, 2, 3 };
    MyStruct foo = { .bax = 2 };
    MyStruct foo_magic = {
        .bax = 2,
    };
    call(MyStruct {}, Bar {.soo = 1,});
    call(MyStruct {1, 2, 3});
    MyStruct foo = (MyStruct)call(MyStruct {1, 2, 3});
    MyStruct foo = (MyStruct)call(MyStruct {1, 2, 3,});
}
================================================================================
body_macro_with_arg
================================================================================

fn String Token.to_string(&self, Allocator allocator) @dynamic {
    @pool(allocator)
    {
        DString builder = dstring::temp_new();
        if (foo) {return 0;
        }
        return builder.copy_str(allocator);
    };
}

--------------------------------------------------------------------------------
fn String Token.to_string(&self, Allocator allocator) @dynamic
{
    @pool(allocator) {
        DString builder = dstring::temp_new();
        if (foo) {
            return 0;
        }
        return builder.copy_str(allocator);
    };
}
================================================================================
body_macro_no_arg
================================================================================

fn String Token.to_string(&self, Allocator allocator) @dynamic {
    @pool
    {
        DString builder = dstring::temp_new();
        if (foo) {return 0;
        }
        return builder.copy_str(allocator);
    };
}

--------------------------------------------------------------------------------
fn String Token.to_string(&self, Allocator allocator) @dynamic
{
    @pool {
        DString builder = dstring::temp_new();
        if (foo) {
            return 0;
        }
        return builder.copy_str(allocator);
    };
}
================================================================================
expr_block_standalone
================================================================================

fn  char[   ]   ! test   ()
{
    {| int a = 0; return a+1; |}  ! ;  
    return 0;
}

--------------------------------------------------------------------------------
fn char[]! test()
{
    {|
        int a = 0;
        return a + 1;
    |}!;
    return 0;
}
================================================================================
expr_block_standalone_body_macro
================================================================================

fn String Token.to_string(&self, Allocator allocator) @dynamic {
    @pool()
    {
        DString builder = dstring::temp_new();
        {| int a = 2; return a;
        |}!!;
        return builder.copy_str(allocator);
    };
}

--------------------------------------------------------------------------------
fn String Token.to_string(&self, Allocator allocator) @dynamic
{
    @pool() {
        DString builder = dstring::temp_new();
        {|
            int a = 2;
            return a;
        |}!!;
        return builder.copy_str(allocator);
    };
}
================================================================================
array_with_parens
================================================================================

fn void main()
{
int[][4] wrapped_array = { (a + 1 + 3), (b + 1 & 2), (1 ||2&&3)};
}

--------------------------------------------------------------------------------
fn void main()
{
    int[][4] wrapped_array = { (a + 1 + 3), (b + 1 & 2), (1 || 2 && 3) };
}
================================================================================
array_with_parens_single_wrap
================================================================================

fn void main()
{
int[][4] wrapped_array = { (a + 1 + 3), (b + 1 & 2), (1 ||2&&3), (boar + foo + aso)};
}

--------------------------------------------------------------------------------
fn void main()
{
    int[][4] wrapped_array = {
        (a + 1 + 3), (b + 1 & 2), (1 || 2 && 3), (boar + foo + aso)
    };
}
================================================================================
array_with_parens_multi_wrap
================================================================================

fn void main()
{
int[][4] wrapped_array = { (a + 1 + 3), (b + 1 & 2), (1 ||2&&3), (boar + foo + aso),};
}

--------------------------------------------------------------------------------
fn void main()
{
    int[][4] wrapped_array = {
        (a + 1 + 3),
        (b + 1 & 2),
        (1 || 2 && 3),
        (boar + foo + aso),
    };
}
================================================================================
designated_initializers_with_comments
================================================================================

fn void main()
{
    argparse::ArgParse agp = {  //  inline2
        // stuff
        .description = "c3 code formatting tool",
        // another
        .usage = "[options] file1 .. fileN", // maybe inline
        .options = { 
            // one moar
            .foo = {1, 2, 3, // another inline
            },
        }, 
    };
}

--------------------------------------------------------------------------------
fn void main()
{
    argparse::ArgParse agp = {  //  inline2
        // stuff
        .description = "c3 code formatting tool",
        // another
        .usage = "[options] file1 .. fileN",  // maybe inline
        .options = {
            // one moar
            .foo = {
                1,
                2,
                3,  // another inline
            },
        },
    };
}
================================================================================
struct_init_with_fn_pointers
================================================================================

TestContext state @local  = {
.foo = 1, 
    .setup_fn = fn void!() {
        io::printn("new test setup");
        // initialize something heavy (maybe a DB)
        state.n_runs = 777;
    }, 
    .teardown_fn = fn void!() { // inline
        state.n_runs = 0;
        io::printn("test teardown"); // inline
    },
.bar = 1, 
};

--------------------------------------------------------------------------------
TestContext state @local = {
    .foo = 1,
    .setup_fn = fn void! () {
        io::printn("new test setup");
        // initialize something heavy (maybe a DB)
        state.n_runs = 777;
    },
    .teardown_fn = fn void! () {  // inline
        state.n_runs = 0;
        io::printn("test teardown");  // inline
    },
    .bar = 1,
};
================================================================================
struct_init_with_sub_fn
================================================================================

TestContext state @local = {
    .foo = 1, 
    .sub_struct ={
        .another = {1, 2, 3},
        .setup_fn = fn void! (int a, int b, $typeof(c) c) {
            io::printn("new test setup");
            // initialize something heavy (maybe a DB)
            state.n_runs = 777;
        }, 
        .sub_field = 1
    }, 
    .teardown_fn = fn void!() { // inline
        state.n_runs = 0;
        io::printn("test teardown"); // inline
    },
    .bar = 1, 
};

--------------------------------------------------------------------------------
TestContext state @local = {
    .foo = 1,
    .sub_struct = {
        .another = {
            1,
            2,
            3
        },
        .setup_fn = fn void! (int a, int b, $typeof(c) c) {
            io::printn("new test setup");
            // initialize something heavy (maybe a DB)
            state.n_runs = 777;
        },
        .sub_field = 1
    },
    .teardown_fn = fn void! () {  // inline
        state.n_runs = 0;
        io::printn("test teardown");  // inline
    },
    .bar = 1,
};
================================================================================
struct_init_with_sub_previous_sub_struct
================================================================================

TestContext state @local = {
    .foo = 1, 
    .sub_struct ={
        .sub_field = 1,
        .sub_field = 2
    }, 
    .teardown_fn = fn void!() { // inline
        state.n_runs = 0;
        io::printn("test teardown"); // inline
    },
    .bar = 1, 
};

--------------------------------------------------------------------------------
TestContext state @local = {
    .foo = 1,
    .sub_struct = {
        .sub_field = 1,
        .sub_field = 2
    },
    .teardown_fn = fn void! () {  // inline
        state.n_runs = 0;
        io::printn("test teardown");  // inline
    },
    .bar = 1,
};
================================================================================
inline_code_flow
================================================================================
fn void main()
{
    foreach (&c : s) if (c.is_upper() @pure) *c += 'a' - 'A';
    foreach (&c : s) if (c.is_upper() @pure) &c = null;
    foreach (&c : s) if (c.is_upper() @pure) return 0;
}
--------------------------------------------------------------------------------
fn void main()
{
    foreach (&c : s) if (c.is_upper() @pure) *c += 'a' - 'A';
    foreach (&c : s) if (c.is_upper() @pure) &c = null;
    foreach (&c : s) if (c.is_upper() @pure) return 0;
}
================================================================================
array_inside_struct_1st_brace_new_line
================================================================================
fn void test_str_set_next_arg_missing_value_with_eqchar()
{
    argparse::ArgParse agp = {
        .description = "test ArgParse program",
        .options = {{
                .short_name = 'f',
                .long_name = "flt",
                .value = &val
            },
        }
    };
}
--------------------------------------------------------------------------------
fn void test_str_set_next_arg_missing_value_with_eqchar()
{
    argparse::ArgParse agp = {
        .description = "test ArgParse program",
        .options = {
            {
                .short_name = 'f',
                .long_name = "flt",
                .value = &val
            },
        }
    };
}
================================================================================
expr_block_in_functions
================================================================================

fn  char[   ]   ! test   ()
{
    call( {|
        io::printfn("Send %d", a);
        a++;
    |}, b, c);

    @body({|
        io::printfn("Send %d", a);
        a++;
    |}, b, c);
}

--------------------------------------------------------------------------------
fn char[]! test()
{
    call( {|
        io::printfn("Send %d", a);
        a++;
    |}, b, c);

    @body( {|
        io::printfn("Send %d", a);
        a++;
    |}, b, c);
}
================================================================================
defer_do_while 
================================================================================
fn void main(){
    defer if (free) libc::free(res);

    defer (try err) libc::free(res);

    defer (try err) (void)libc::free(res);

    defer do {
        if (a == 1) break;
        defer1();
    } while(0);

    defer do {
        if (a == 1) break;
        defer1();
    };

    defer (void){|
        defer printf("Hello!\n");
        defer printf("2\n");
        return 34;
    |};
}
--------------------------------------------------------------------------------
fn void main()
{
    defer if (free) libc::free(res);

    defer (try err) libc::free(res);

    defer (try err) (void)libc::free(res);

    defer do {
        if (a == 1) break;
        defer1();
    } while(0);

    defer do {
        if (a == 1) break;
        defer1();
    };

    defer (void){|
        defer printf("Hello!\n");
        defer printf("2\n");
        return 34;
    |};
}
================================================================================
while_with_body_macro_inline
================================================================================
fn void main()
{
    while (true) @thing()
    {
        do_something();
        break;
    };
    for (;;) @thing()
    {
        do_something();
        break;
    };
    if (true) @thing()
    {
        do_something();
    };
}
--------------------------------------------------------------------------------
fn void main()
{
    while (true) @thing() {
        do_something();
        break;
    };
    for (;;) @thing() {
        do_something();
        break;
    };
    if (true) @thing() {
        do_something();
    };
}
================================================================================
defer_in_defer
================================================================================
fn void test()
{
    defer
    {
        defer test1();
        test2();
        defer test3();
    }
    test4();
}

fn void test_line()
{
    defer { defer test1(); }
}
--------------------------------------------------------------------------------
fn void test()
{
    defer {
        defer test1();
        test2();
        defer test3();
    }
    test4();
}

fn void test_line()
{
    defer {
        defer test1();
    }
}
================================================================================
function_pointer_in_array
================================================================================
fn void test()
{
    ArgParse agp = {
        .options = {
            {
                .short_name = 1,
                .callback = fn void! (int a) {
                    return 0;
                },
            }
        },
    };
}
--------------------------------------------------------------------------------
fn void test()
{
    ArgParse agp = {
        .options = {
            {
                .short_name = 1,
                .callback = fn void! (int a) {
                    return 0;
                },
            }
        },
    };
}
================================================================================
function_pointer_in_array_2
================================================================================
fn void test()
{
    ArgParse agp = {
        .options = {
            {
                .short_name = 'R',
                .value = &config,
                .help = "optimization level [default: O0]",
                .callback = fn void! (ArgOpt* opt, String value) {
                    int level = value.to_integer(int)!;
                    if (level ) {
                        return 0;
                    }
                },
            },
            {.short_name = 'F'},
            {
                .short_name = 'O',
                .value = &config,
                .help = "optimization level [default: O0]",
                .callback = fn void! (ArgOpt* opt, String value) {
                    int level = value.to_integer(int)!;
                    if (level ) {
                        return 0;
                    }
                }
            },
            {.short_name = 'F'}
        },
        .flags = {},
        .other = {.boo = 2},
    };
}
--------------------------------------------------------------------------------
fn void test()
{
    ArgParse agp = {
        .options = {
            {
                .short_name = 'R',
                .value = &config,
                .help = "optimization level [default: O0]",
                .callback = fn void! (ArgOpt* opt, String value) {
                    int level = value.to_integer(int)!;
                    if (level) {
                        return 0;
                    }
                },
            },
            {
                .short_name = 'F'
            },
            {
                .short_name = 'O',
                .value = &config,
                .help = "optimization level [default: O0]",
                .callback = fn void! (ArgOpt* opt, String value) {
                    int level = value.to_integer(int)!;
                    if (level) {
                        return 0;
                    }
                }
            },
            {
                .short_name = 'F'
            }
        },
        .flags = {},
        .other = {
            .boo = 2
        },
    };
}
